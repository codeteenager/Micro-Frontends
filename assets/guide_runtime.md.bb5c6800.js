import{_ as s,o as n,c as a,Q as l}from"./chunks/framework.5da65e64.js";const p="/Micro-Frontends/application/runtime/1.png",e="/Micro-Frontends/application/runtime/3.webp",o="/Micro-Frontends/application/runtime/2.png",F=JSON.parse('{"title":"运行时框架","description":"","frontmatter":{},"headers":[],"relativePath":"guide/runtime.md","filePath":"guide/runtime.md","lastUpdated":1683295414000}'),t={name:"guide/runtime.md"},r=l(`<h1 id="运行时框架" tabindex="-1">运行时框架 <a class="header-anchor" href="#运行时框架" aria-label="Permalink to &quot;运行时框架&quot;">​</a></h1><p>运行时框架主要做了以下这些事：</p><ul><li>应用加载 - 根据注册的子应用，通过给定的 url，加载约定格式的子应用入口，并挂载到给定位置 部分框架是根据类似 manifest 的数据，来获取子应用注册情况以及入口地址 部分框架支持和管理平台配合，运行时接受平台动态注入的入口地址 (也有框架宣称运行时注入和管理平台解耦，但实际是如果不用，就得自己实现注入逻辑) JS 做入口更纯粹，用 HTML 做入口更易于旧项目改造 业界目前常用两种入口格式， HTML 和 JS 父子入口组合(即确定依赖关系)也有两种模式，构建时组合 和 运行时组合</li><li>生命周期 - 加载 / 挂载 / 更新 / 卸载 等 加载 / 挂载时做的初始化、权限守卫、i18n 语言等 卸载时做清理，如卸载 script 标签、style 标签、子应用 dom 等 以及路由、父子通信时做双向更新的桥梁</li><li>路由同步 - 子应用的路由切换时，同步更新 url；url 跳转 / 更新时，同步更新子应用 也就是对子应用做到路由等同于 url</li><li>应用通信 - 是说支持父子应用之间便捷地相互通信，不像 postMessage 那样难用 (指字符串) 什么。</li><li>沙箱隔离 - 为了各个应用「互补干扰」，需要把各个应用在“隔离”的环境中执行 缺少隔离的话，CSS 全局样式可能 冲突混乱，JS 全局变量可能被 污染 / 篡改 / 替换。</li><li>异常处理 - 以上所有东西在报错时的统一处理，比如加载失败、或者路由匹配失败</li></ul><h2 id="应用加载" tabindex="-1">应用加载 <a class="header-anchor" href="#应用加载" aria-label="Permalink to &quot;应用加载&quot;">​</a></h2><p>App Entry作为子应用的加载入口，微前端框架根据注册的子应用，通过给定的 url，加载约定格式的子应用入口，并挂载到给定位置，目前业内有两种entry: JS Entry 和 Html Entry。</p><table><thead><tr><th></th><th>说明</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>html</td><td>html作为子应用入口</td><td>解耦更彻底，子应用不依赖于主应用DOM，子应用独立开发，独立部署</td><td>多了一次对html的请求，解析有性能损耗，无法做构建时优化</td></tr><tr><td>js</td><td>js作为子应用入口</td><td>便于做构建时优化</td><td>依赖主应用提供挂载节点，打包产物体积膨胀，资源无法并行加载</td></tr></tbody></table><p>Js Entry 的缺点是：</p><ul><li>子应用更新打包后的 js bundle 名称会变化，主应用需要保证每次获取都是最新的 js bundle</li><li>子应用所有资源打包到一个文件中，会失去 css 提取、静态资源并行加载、首屏加载(体积巨大)等优化。</li><li>需要在子应用打包过程中，修改相应的配置以补全子应用 js 资源的路径。</li></ul><p>而Html Entry只需要指定子应用的 html 入口即可，微前端框架在加载 html 字符串后，从中提取出 css、js 资源，运行子应用时，安装样式、执行脚本，运行脚本中提供的生命周期钩子。因此优点也很明显：</p><ul><li>无需关心应用打包后的 js 名称变化的问题。</li><li>仍然可以享受 css提取、静态资源并行加载（内部使用 Promise.all 并行发出请求资源）、首屏加载等优化。</li><li>请求资源时，自动补全资源路径。</li></ul><h3 id="js-entry" tabindex="-1">JS Entry <a class="header-anchor" href="#js-entry" aria-label="Permalink to &quot;JS Entry&quot;">​</a></h3><p>JS Entry 的方式通常是子应用将资源打成一个 entry script，要求子应用的所有资源打包到一个 js bundle 里，包括 css、图片等资源。像single-spa通常是结合SystemJS来实现，在single-spa框架中，基座会检测浏览器url的变化，在变化时往往通过SystemJS的import映射，来加载不同的子应用js。</p><h4 id="import-maps" tabindex="-1">Import maps <a class="header-anchor" href="#import-maps" aria-label="Permalink to &quot;Import maps&quot;">​</a></h4><p><a href="https://github.com/WICG/import-maps" target="_blank" rel="noreferrer">Import maps</a>这个功能是Chrome 89才支持的。它是对import的一个映射处理，让你控制在js中使用import时，到底从哪个url获取这些库。</p><p>比如通常我们会在js中，以下面这种方式引入模块：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> moment </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;moment&quot;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">import</span><span style="color:#24292E;"> moment </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;moment&quot;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>正常情况下肯定是node_modules中引入，但是现在我们在html中加入下面的代码：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">script</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">type</span><span style="color:#F97583;">=</span><span style="color:#9ECBFF;">&quot;importmap&quot;</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">    {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#9ECBFF;">&quot;imports&quot;</span><span style="color:#E1E4E8;">: {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#9ECBFF;">&quot;moment&quot;</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">&quot;/moment/src/moment.js&quot;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#85E89D;">script</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">script</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">type</span><span style="color:#D73A49;">=</span><span style="color:#032F62;">&quot;importmap&quot;</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">    {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#032F62;">&quot;imports&quot;</span><span style="color:#24292E;">: {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#032F62;">&quot;moment&quot;</span><span style="color:#24292E;">: </span><span style="color:#032F62;">&quot;/moment/src/moment.js&quot;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">&lt;/</span><span style="color:#22863A;">script</span><span style="color:#24292E;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>这里/moment/src/moment.js这个地址换成一个cdn资源也是可以的。最终达到的效果就是：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> moment </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;/moment/src/moment.js&quot;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">import</span><span style="color:#24292E;"> moment </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;/moment/src/moment.js&quot;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>有了Import maps，import的语法就可以直接在浏览器中使用，而不再需要webpack来帮我们进行处理，不需要从node_modules中去加载库。</p><p>Import maps甚至还有一个兜底的玩法：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#9ECBFF;">&quot;imports&quot;</span><span style="color:#E1E4E8;">: {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#9ECBFF;">&quot;jquery&quot;</span><span style="color:#E1E4E8;">: [</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#9ECBFF;">&quot;https://某CDN/jquery.min.js&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#9ECBFF;">&quot;/node_modules/jquery/dist/jquery.js&quot;</span></span>
<span class="line"><span style="color:#E1E4E8;">        ]</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#032F62;">&quot;imports&quot;</span><span style="color:#24292E;">: {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#032F62;">&quot;jquery&quot;</span><span style="color:#24292E;">: [</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#032F62;">&quot;https://某CDN/jquery.min.js&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#032F62;">&quot;/node_modules/jquery/dist/jquery.js&quot;</span></span>
<span class="line"><span style="color:#24292E;">        ]</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>当cdn无效时，再从本地库中获取内容。</p><p>尽管Import maps非常强大，但是毕竟浏览器兼容性还并不是很好，所以就有了我们的polifill方案：SystemJS</p><h4 id="systemjs" tabindex="-1">SystemJS <a class="header-anchor" href="#systemjs" aria-label="Permalink to &quot;SystemJS&quot;">​</a></h4><p>SystemJs是一个通用的模块加载器，有属于自己的模块化规范。他能在浏览器和node环境上动态加载模块，微前端的核心就是加载子应用，因此将子应用打包成模块，在浏览器中通过SystemJs来加载模块。SystemJS可兼容到IE11，但是它对于插件版本要求非常严格，而且变化非常大，兼容性也不是特别好，使用体验也不是很好，所以目前实践中用的非常少。它同样支持import映射，但是它的语法稍有不同:</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">script</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">src</span><span style="color:#F97583;">=</span><span style="color:#9ECBFF;">&quot;system.js&quot;</span><span style="color:#E1E4E8;">&gt;&lt;/</span><span style="color:#85E89D;">script</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">script</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">type</span><span style="color:#F97583;">=</span><span style="color:#9ECBFF;">&quot;systemjs-importmap&quot;</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">{</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#9ECBFF;">&quot;imports&quot;</span><span style="color:#E1E4E8;">: {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#9ECBFF;">&quot;lodash&quot;</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">&quot;https://unpkg.com/lodash@4.17.10/lodash.js&quot;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#85E89D;">script</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">script</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">src</span><span style="color:#D73A49;">=</span><span style="color:#032F62;">&quot;system.js&quot;</span><span style="color:#24292E;">&gt;&lt;/</span><span style="color:#22863A;">script</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">script</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">type</span><span style="color:#D73A49;">=</span><span style="color:#032F62;">&quot;systemjs-importmap&quot;</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">{</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#032F62;">&quot;imports&quot;</span><span style="color:#24292E;">: {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#032F62;">&quot;lodash&quot;</span><span style="color:#24292E;">: </span><span style="color:#032F62;">&quot;https://unpkg.com/lodash@4.17.10/lodash.js&quot;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;">&lt;/</span><span style="color:#22863A;">script</span><span style="color:#24292E;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>在浏览器中引入system.js后，会去解析type为systemjs-importmap的script下的import映射。</p><h3 id="html-entry" tabindex="-1">Html Entry <a class="header-anchor" href="#html-entry" aria-label="Permalink to &quot;Html Entry&quot;">​</a></h3><p>HTML Entry 是由 <a href="https://github.com/kuitos/import-html-entry" target="_blank" rel="noreferrer">import-html-entry</a> 库实现的，这个库主要做了这些事情：</p><ol><li>加载 entry html (index.html) 的内容到内存。</li><li>将 entry html 中的 css、js、link 等标签下的内容获取出来(包含外部的和内联的)，整理成网页所需的 js、css 列表。并将无用标签去掉(例如注释、ignore 等)。</li><li>加载所有外链 js 脚本，并将这些外链 js 和内联 js 一起整理为 script list。</li><li>加载所有外链 css 文件，并将其以内联(<code>&lt;style/&gt;</code>)的方式插入到 entry html 中。</li><li>将处理后的 entry html 和待执行的 script list 返回给调用方(基座)。</li></ol><p>通过 http 请求加载指定地址的首屏内容即 html 页面，然后解析这个 html 模版得到 template, scripts , entry, styles。</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">{</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">template</span><span style="color:#E1E4E8;">: 经过处理的脚本，link、script 标签都被注释掉了,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">scripts</span><span style="color:#E1E4E8;">: [脚本的http地址 或者 { async: </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">, src: xx } 或者 代码块],</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">styles</span><span style="color:#E1E4E8;">: [样式的http地址],</span></span>
<span class="line"><span style="color:#E1E4E8;"> 	</span><span style="color:#B392F0;">entry</span><span style="color:#E1E4E8;">: 入口脚本的地址，要不是标有 entry 的 script 的 src，要不就是最后一个 script 标签的 src</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">{</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">template</span><span style="color:#24292E;">: 经过处理的脚本，link、script 标签都被注释掉了,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">scripts</span><span style="color:#24292E;">: [脚本的http地址 或者 { async: </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">, src: xx } 或者 代码块],</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">styles</span><span style="color:#24292E;">: [样式的http地址],</span></span>
<span class="line"><span style="color:#24292E;"> 	</span><span style="color:#6F42C1;">entry</span><span style="color:#24292E;">: 入口脚本的地址，要不是标有 entry 的 script 的 src，要不就是最后一个 script 标签的 src</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>然后远程加载 styles 中的样式内容，将 template 模版中注释掉的 link 标签替换为相应的 style 元素。</p><p>然后向外暴露一个 Promise 对象</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">{</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// template 是 link 替换为 style 后的 template</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#B392F0;">template</span><span style="color:#E1E4E8;">: embedHTML,</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#6A737D;">// 静态资源地址</span></span>
<span class="line"><span style="color:#E1E4E8;">	assetPublicPath,</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#6A737D;">// 获取外部脚本，最终得到所有脚本的代码内容</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#B392F0;">getExternalScripts</span><span style="color:#E1E4E8;">: () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getExternalScripts</span><span style="color:#E1E4E8;">(scripts, fetch),</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#6A737D;">// 获取外部样式文件的内容</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#B392F0;">getExternalStyleSheets</span><span style="color:#E1E4E8;">: () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getExternalStyleSheets</span><span style="color:#E1E4E8;">(styles, fetch),</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#6A737D;">// 脚本执行器，让 JS 代码(scripts)在指定 上下文 中运行</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#B392F0;">execScripts</span><span style="color:#E1E4E8;">: (</span><span style="color:#FFAB70;">proxy</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">strictGlobal</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">		</span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">scripts.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">			</span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">Promise</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">resolve</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">		}</span></span>
<span class="line"><span style="color:#E1E4E8;">		</span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">execScripts</span><span style="color:#E1E4E8;">(entry, scripts, proxy, { fetch, strictGlobal });</span></span>
<span class="line"><span style="color:#E1E4E8;">	}</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">{</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// template 是 link 替换为 style 后的 template</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#6F42C1;">template</span><span style="color:#24292E;">: embedHTML,</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#6A737D;">// 静态资源地址</span></span>
<span class="line"><span style="color:#24292E;">	assetPublicPath,</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#6A737D;">// 获取外部脚本，最终得到所有脚本的代码内容</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#6F42C1;">getExternalScripts</span><span style="color:#24292E;">: () </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getExternalScripts</span><span style="color:#24292E;">(scripts, fetch),</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#6A737D;">// 获取外部样式文件的内容</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#6F42C1;">getExternalStyleSheets</span><span style="color:#24292E;">: () </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getExternalStyleSheets</span><span style="color:#24292E;">(styles, fetch),</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#6A737D;">// 脚本执行器，让 JS 代码(scripts)在指定 上下文 中运行</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#6F42C1;">execScripts</span><span style="color:#24292E;">: (</span><span style="color:#E36209;">proxy</span><span style="color:#24292E;">, </span><span style="color:#E36209;">strictGlobal</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">		</span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">scripts.</span><span style="color:#005CC5;">length</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">			</span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">Promise</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">resolve</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">		}</span></span>
<span class="line"><span style="color:#24292E;">		</span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">execScripts</span><span style="color:#24292E;">(entry, scripts, proxy, { fetch, strictGlobal });</span></span>
<span class="line"><span style="color:#24292E;">	}</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>在 import-html-entry 库处理完之后，基座在需要的加载子应用时候将这个 html 放到对应的 DOM 容器节点，并执行 script list，即完成子应用的加载。</p><p><img src="`+p+`" alt=""></p><blockquote><p>了解更多</p></blockquote><ul><li><a href="https://blog.csdn.net/m0_66439275/article/details/122792280" target="_blank" rel="noreferrer">HTML Entry 源码分析</a></li><li><a href="https://blog.csdn.net/qq_41800366/article/details/122093720" target="_blank" rel="noreferrer">揭开 import-html-entry 面纱</a></li></ul><h2 id="路由同步" tabindex="-1">路由同步 <a class="header-anchor" href="#路由同步" aria-label="Permalink to &quot;路由同步&quot;">​</a></h2><p>子应用注册的时候，提供子应用激活规则 (路由字符串 或 函数)。因此，监听 hashchange 和 popstate 事件，在事件回调函数中，根据注册的子应用激活规则，卸载/激活子应用。</p><p>以 Vue-Router 的 history 模式为例，在切换路由时，通常会做三件重要事情：执行一连串的 hook 函数、更新url、router-view 更新，其中更新 url，就是通过 pushState/replaceState 的形式实现的。因此重写并增强 history.pushState 和 history.replaceState 方法，在执行它们的时候，可以拿到执行前、执行后的 url，对比是否有变化，如果有，根据注册的子应用激活规则，卸载/激活子应用。</p><p>以single-spa为例：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// We will trigger an app change for any routing events.</span></span>
<span class="line"><span style="color:#E1E4E8;">  window.</span><span style="color:#B392F0;">addEventListener</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;hashchange&quot;</span><span style="color:#E1E4E8;">, urlReroute);</span></span>
<span class="line"><span style="color:#E1E4E8;">  window.</span><span style="color:#B392F0;">addEventListener</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;popstate&quot;</span><span style="color:#E1E4E8;">, urlReroute);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// Monkeypatch addEventListener so that we can ensure correct timing</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">originalAddEventListener</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> window.addEventListener;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">originalRemoveEventListener</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> window.removeEventListener;</span></span>
<span class="line"><span style="color:#E1E4E8;">  window.</span><span style="color:#B392F0;">addEventListener</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">eventName</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">fn</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">typeof</span><span style="color:#E1E4E8;"> fn </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;function&quot;</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span></span>
<span class="line"><span style="color:#E1E4E8;">        routingEventsListeningTo.</span><span style="color:#B392F0;">indexOf</span><span style="color:#E1E4E8;">(eventName) </span><span style="color:#F97583;">&gt;=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">!</span><span style="color:#B392F0;">find</span><span style="color:#E1E4E8;">(capturedEventListeners[eventName], (</span><span style="color:#FFAB70;">listener</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> listener </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> fn)</span></span>
<span class="line"><span style="color:#E1E4E8;">      ) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        capturedEventListeners[eventName].</span><span style="color:#B392F0;">push</span><span style="color:#E1E4E8;">(fn);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> originalAddEventListener.</span><span style="color:#B392F0;">apply</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">arguments</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">  };</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  window.</span><span style="color:#B392F0;">removeEventListener</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">eventName</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">listenerFn</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">typeof</span><span style="color:#E1E4E8;"> listenerFn </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;function&quot;</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (routingEventsListeningTo.</span><span style="color:#B392F0;">indexOf</span><span style="color:#E1E4E8;">(eventName) </span><span style="color:#F97583;">&gt;=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        capturedEventListeners[eventName] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> capturedEventListeners[</span></span>
<span class="line"><span style="color:#E1E4E8;">          eventName</span></span>
<span class="line"><span style="color:#E1E4E8;">        ].</span><span style="color:#B392F0;">filter</span><span style="color:#E1E4E8;">((</span><span style="color:#FFAB70;">fn</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> fn </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> listenerFn);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> originalRemoveEventListener.</span><span style="color:#B392F0;">apply</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">arguments</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">  };</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  window.history.pushState </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">patchedUpdateState</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">    window.history.pushState,</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#9ECBFF;">&quot;pushState&quot;</span></span>
<span class="line"><span style="color:#E1E4E8;">  );</span></span>
<span class="line"><span style="color:#E1E4E8;">  window.history.replaceState </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">patchedUpdateState</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">    window.history.replaceState,</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#9ECBFF;">&quot;replaceState&quot;</span></span>
<span class="line"><span style="color:#E1E4E8;">  );</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// We will trigger an app change for any routing events.</span></span>
<span class="line"><span style="color:#24292E;">  window.</span><span style="color:#6F42C1;">addEventListener</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;hashchange&quot;</span><span style="color:#24292E;">, urlReroute);</span></span>
<span class="line"><span style="color:#24292E;">  window.</span><span style="color:#6F42C1;">addEventListener</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;popstate&quot;</span><span style="color:#24292E;">, urlReroute);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// Monkeypatch addEventListener so that we can ensure correct timing</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">originalAddEventListener</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> window.addEventListener;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">originalRemoveEventListener</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> window.removeEventListener;</span></span>
<span class="line"><span style="color:#24292E;">  window.</span><span style="color:#6F42C1;">addEventListener</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> (</span><span style="color:#E36209;">eventName</span><span style="color:#24292E;">, </span><span style="color:#E36209;">fn</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">typeof</span><span style="color:#24292E;"> fn </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;function&quot;</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span></span>
<span class="line"><span style="color:#24292E;">        routingEventsListeningTo.</span><span style="color:#6F42C1;">indexOf</span><span style="color:#24292E;">(eventName) </span><span style="color:#D73A49;">&gt;=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">!</span><span style="color:#6F42C1;">find</span><span style="color:#24292E;">(capturedEventListeners[eventName], (</span><span style="color:#E36209;">listener</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> listener </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> fn)</span></span>
<span class="line"><span style="color:#24292E;">      ) {</span></span>
<span class="line"><span style="color:#24292E;">        capturedEventListeners[eventName].</span><span style="color:#6F42C1;">push</span><span style="color:#24292E;">(fn);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> originalAddEventListener.</span><span style="color:#6F42C1;">apply</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">arguments</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">  };</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  window.</span><span style="color:#6F42C1;">removeEventListener</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> (</span><span style="color:#E36209;">eventName</span><span style="color:#24292E;">, </span><span style="color:#E36209;">listenerFn</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">typeof</span><span style="color:#24292E;"> listenerFn </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;function&quot;</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (routingEventsListeningTo.</span><span style="color:#6F42C1;">indexOf</span><span style="color:#24292E;">(eventName) </span><span style="color:#D73A49;">&gt;=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        capturedEventListeners[eventName] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> capturedEventListeners[</span></span>
<span class="line"><span style="color:#24292E;">          eventName</span></span>
<span class="line"><span style="color:#24292E;">        ].</span><span style="color:#6F42C1;">filter</span><span style="color:#24292E;">((</span><span style="color:#E36209;">fn</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> fn </span><span style="color:#D73A49;">!==</span><span style="color:#24292E;"> listenerFn);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> originalRemoveEventListener.</span><span style="color:#6F42C1;">apply</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">arguments</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">  };</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  window.history.pushState </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">patchedUpdateState</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">    window.history.pushState,</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#032F62;">&quot;pushState&quot;</span></span>
<span class="line"><span style="color:#24292E;">  );</span></span>
<span class="line"><span style="color:#24292E;">  window.history.replaceState </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">patchedUpdateState</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">    window.history.replaceState,</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#032F62;">&quot;replaceState&quot;</span></span>
<span class="line"><span style="color:#24292E;">  );</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br></div></div><p>以上主要是增加了hashchange、popstate两个监听，监听url的变化。同时重写pushState以及replaceState方法，在方法中调用原有方法后执行如何处理子应用的逻辑监听hashchange及popstate事件，事件触发后执行如何处理子应用的逻辑。</p><h2 id="生命周期" tabindex="-1">生命周期 <a class="header-anchor" href="#生命周期" aria-label="Permalink to &quot;生命周期&quot;">​</a></h2><p>single-spa的一个关键点就是生命周期，子应用生命周期包含bootstrap，mount，unmount三个回调函数。主应用在管理子应用的时候，通过子应用暴露的生命周期函数来实现子应用的启动和卸载。</p><p><img src="`+e+'" alt=""></p><ul><li>load：当应用匹配路由时就会加载脚本（非函数，只是一种状态）。</li><li>bootstrap：应用内容首次挂载到页面前调用。</li><li>Mount：当主应用判定需要激活这个子应用时会调用, 实现子应用的挂载、页面渲染等逻辑。</li><li>unmount：当主应用判定需要卸载这个子应用时会调用, 实现组件卸载、清理事件监听等逻辑。</li><li>unload：非必要函数，一般不使用。unload之后会重新启动bootstrap流程。</li></ul><h2 id="沙箱隔离" tabindex="-1">沙箱隔离 <a class="header-anchor" href="#沙箱隔离" aria-label="Permalink to &quot;沙箱隔离&quot;">​</a></h2><p>子应用和基座的隔离主要有两点：</p><ul><li>样式隔离</li><li>js 隔离</li></ul><h3 id="样式隔离" tabindex="-1">样式隔离 <a class="header-anchor" href="#样式隔离" aria-label="Permalink to &quot;样式隔离&quot;">​</a></h3><h4 id="shadowdom" tabindex="-1">shadowDOM <a class="header-anchor" href="#shadowdom" aria-label="Permalink to &quot;shadowDOM&quot;">​</a></h4><p>目前相对来说使用最多的样式隔离机制 <img src="'+o+`" alt=""></p><h4 id="bem、css-modules" tabindex="-1">BEM、CSS Modules <a class="header-anchor" href="#bem、css-modules" aria-label="Permalink to &quot;BEM、CSS Modules&quot;">​</a></h4><p>BEM：Block Element Module命名约束</p><ul><li>B：Block一个独立的模块，一个本身就有意义的独立实体，比如：header、menu、container</li><li>E：Element元素，块的一部分但是自身没有独立的含义，比如：header title、container input</li><li>M：Modifier修饰符，块或者元素的一些状态或者属性标志，比如：small、checked</li></ul><div class="language-css vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">模块：</span><span style="color:#B392F0;">.Block</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">模块多单词： </span><span style="color:#B392F0;">.Header-Block</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">模块_状态： </span><span style="color:#B392F0;">.Block_Modifier</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">模块__子元素： </span><span style="color:#B392F0;">.Block__Element</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">模块__子元素_状态： </span><span style="color:#B392F0;">.Block__Element_Modifier</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">模块：</span><span style="color:#6F42C1;">.Block</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">模块多单词： </span><span style="color:#6F42C1;">.Header-Block</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">模块_状态： </span><span style="color:#6F42C1;">.Block_Modifier</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">模块__子元素： </span><span style="color:#6F42C1;">.Block__Element</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">模块__子元素_状态： </span><span style="color:#6F42C1;">.Block__Element_Modifier</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>CSS Modules： 代码中的每一个类名都是引入对象的一个属性，通过这种方式，即可在使用时明确指定所引用的 css 样式。并且 CSS Modules 在打包的时候会自动将类名转换成 hash 值，完全杜绝 css 类名冲突的问题；</p><h4 id="css-in-js" tabindex="-1">CSS in JS <a class="header-anchor" href="#css-in-js" aria-label="Permalink to &quot;CSS in JS&quot;">​</a></h4><p>使用JS写CSS，也是目前比较主流的方案，完全不需要些单独的 css 文件，所有的 css 代码全部放在组件内部，以实现 css 的模块化，但对于历史代码不好处理</p><h4 id="postcss" tabindex="-1">postcss <a class="header-anchor" href="#postcss" aria-label="Permalink to &quot;postcss&quot;">​</a></h4><p>使用postcss，在全局对所有class添加统一的前缀，但是在编译时处理，会增加编译时间；</p><h3 id="js隔离" tabindex="-1">JS隔离 <a class="header-anchor" href="#js隔离" aria-label="Permalink to &quot;JS隔离&quot;">​</a></h3><p>js 隔离的核心是在基座和子应用中使用不同的上下文 (global env)，从而达成基座和子应用之间 js 运行互不影响。</p><blockquote><p>简单来说，就是给子应用单独的 window，避免对基座的 window 造成污染。</p></blockquote><h4 id="qiankun的沙箱机制" tabindex="-1">qiankun的沙箱机制 <a class="header-anchor" href="#qiankun的沙箱机制" aria-label="Permalink to &quot;qiankun的沙箱机制&quot;">​</a></h4><p>qiankun在js隔离上，同样提供了3种方案，分别是：</p><ol><li>LegacySandbox - 传统js沙箱，目前已弃用，需要配置sandbox.loose = true开启。此沙箱使用 Proxy 代理子应用对 window 的操作，将子应用对 window 的操作同步到全局 window 上，造成侵入。但同时会将期间对 window 的新增、删除、修改操作记录到沙箱变量中，在子应用关闭时销毁，再根据记录将 window 还原到初始状态。</li><li>ProxySandbox - 代理js沙箱，非IE浏览器默认使用此沙箱。和 LegacySandbox 同样基于 Proxy 代理子应用对 window 的操作，和 LegacySandbox 不同的是，ProxySandbox 会创建一个虚拟的 window 对象提供给子应用使用，哪怕是在运行时，子应用也不会侵入对 window，实现完全的隔离。</li><li>SnapshotSandbox - 快照 js 沙箱，IE 浏览器默认使用此沙箱。因为 IE 不支持 Proxy。此沙箱的原理是在子应用启动时，创建基座 window 的快照，存到一个变量中，子应用的 window 操作实质上是对这个变量操作。SnapshotSandbox 同样会将子应用运行期间的修改存储至 modifyPropsMap 中，以便在子应用创建和销毁时还原。</li></ol><h4 id="基于iframe的沙箱机制" tabindex="-1">基于iframe的沙箱机制 <a class="header-anchor" href="#基于iframe的沙箱机制" aria-label="Permalink to &quot;基于iframe的沙箱机制&quot;">​</a></h4><p>iframe 标签可以创造一个独立的浏览器级别的运行环境，该环境与主环境隔离，并有自己的 window 上下文；在通信机制上，也可以利用 postMessage 等 API 与宿主环境进行通信。具体来说，在执行 JavaScript 代码上，有以下要求：</p><ol><li>应用间运行时隔离：常见的是使用shadowDOM创建的样式隔离DOM，再使用Proxy拦截JS的执行，代理到shadowDOM所创建的隔离开的DOM上；</li><li>应用间通信：同域：window.parent，不同域：postMessage；或者eventBus等自定义的方式实现；</li><li>路由劫持：</li></ol><ul><li>a. 让 JavaScript 沙箱内路由变更操作在主应用环境生效：但这种对于相对路径的配置，如接口请求处理太繁琐，一般不建议；</li><li>b. 同步沙箱内路由变化至主应用环境：监听iframe路由上下文，同步到主应用路由上，如wujie；</li></ul><h2 id="应用通信" tabindex="-1">应用通信 <a class="header-anchor" href="#应用通信" aria-label="Permalink to &quot;应用通信&quot;">​</a></h2><ul><li>基于URL来进行数据传递，但是传递消息能力弱</li><li>基于CustomEvent实现通信</li><li>基于props主子应用间通信</li><li>使用全局变量、Redus进行通信</li></ul><h2 id="异常处理" tabindex="-1">异常处理 <a class="header-anchor" href="#异常处理" aria-label="Permalink to &quot;异常处理&quot;">​</a></h2><p>当运行中发生错误时，需要对其进行捕获，这里主要监听了error和unhandledrejection两个错误事件。</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">window.</span><span style="color:#B392F0;">addEventListener</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;error&#39;</span><span style="color:#E1E4E8;">, errorHandler);</span></span>
<span class="line"><span style="color:#E1E4E8;">window.</span><span style="color:#B392F0;">addEventListener</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;unhandledrejection&#39;</span><span style="color:#E1E4E8;">, errorHandler);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">window.</span><span style="color:#6F42C1;">addEventListener</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;error&#39;</span><span style="color:#24292E;">, errorHandler);</span></span>
<span class="line"><span style="color:#24292E;">window.</span><span style="color:#6F42C1;">addEventListener</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;unhandledrejection&#39;</span><span style="color:#24292E;">, errorHandler);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div>`,81),c=[r];function i(E,y,u,d,m,b){return n(),a("div",null,c)}const g=s(t,[["render",i]]);export{F as __pageData,g as default};
